# Cache

## Назначение блока

Данный блок представляет собой параметризуемый кэш, позволяющий реализовать любой тип организации адресного пространства: полностью ассоциативный, частично ассоциативный или прямого отображения. Основная цель кэша — минимизация времени доступа центрального процессора к данным, хранящимся в основной памяти.

**Особенности реализации:**

- Поддерживается метод замещения строк кэша LRU (Least Recently Used), обеспечивающий эффективное управление данными.

- Используется стратегия записи write-back, глубина буфера которой задаётся параметром конфигурации.

- Входные и выходные интерфейсы реализованы в соответствии с протоколом AXI4-Lite.

- Поддерживается чтение данных из write-back буфера.

- Хранение до $2^{CPU\_ADDR\_BUF}$ адресов при запросе CPU в занятый кэш.

- Использование внешней Tech. памяти  для получения лучших временных характеристик.

## Параметры конфигурации

*Таблица 1: Параметры конфигурации*
|      Parameter      | Default | Description                                                                          | Value range |
| :-----------------: | :-----: | ------------------------------------------------------------------------------------ | :---------: |
|     `SET_BITS`      |    6    | количество set в кэше. Считается как $2^{SET\_BITS}$                                 |     0-7     |
|    `BLOCK_BITS`     |    2    | количество блоков находящихся в одном  set. Считается как $2^{BLOCK\_BITS}$          |     0-4     |
| `BUFFER_DEPTH_BITS` |    2    | глубину write-back буфера. Считается как $2^{BUFFER\_DEPTH\_BITS}$                   |     0-5     |
|    `DATA_WIDTH`     |   32    | ширина данных системного интерфейса                                                  |    32-64    |
|    `ADDR_WIDTH`     |   32    | ширина адреса системного интерфейса                                                  |    32-64    |
|   `CPU_ADDR_BUF`    |    2    | глубина буфер для хранения адресов со стороны CPU.Считается как $2^{CPU\_ADDR\_BUF}$ |     0-3     |

## Структурная схема блока

На рисунке 1 приведена структурная схема блока кэш.

В состав блока входит:

- AXI4-lite master - интерфейс, через который происходит общение с MEM
- AXI4-lite slave - интерфейс, через который происходит общение с CPU
- Write-back buffer - для отправки в основную память редактированных данных
- Cache - основная логика работы кэша
- LRU - блок, реализующий выбор выталкиваемого блока
- Tech. MEM - внешняя память

![alt text](img/Cache.drawio.svg)

*Рисунок 1: Структура блока кэш*

## Сигналы ввода/вывода

В данном блоке используется интерфейс AXI-Lite.

*Таблица 2: интерфейс общения с внешней памятью кэша*
| Название порта | Направление |        Ширина         | Описание порта             |
| -------------- | :---------: | :-------------------: | -------------------------- |
| `cache_addr_o` |   output    | SET_BITS + BLOCK_BITS | адрес чтения/записи данных |
| `cache_data_i` |    input    |      DATA_WIDTH       | входные данные             |
| `cache_we_o`   |   output    |           1           | разрешение на запись       |
| `cache_en_o`   |   output    |           1           | разрешение работы памяти   |
| `cache_data_o` |   output    |      DATA_WIDTH       | выходные данные            |

*Таблица 3: интерфейс общения с внешней памятью LRU*
| Название порта | Направление |        Ширина                   | Описание порта             |
| -------------- | :---------: | :-------------------:           | -------------------------- |
| `lru_addr_o`   |   output    |       SET_BITS                  | адрес чтения/записи данных |
| `lru_data_i`   |    input    | BLOCK_AMOUNT*(BLOCK_AMOUNT-1)/2 | входные данные             |
| `lru_we_o`     |   output    |           1                     | разрешение на запись       |
| `lru_en_o`     |   output    |           1                     | разрешение работы памяти   |
| `lru_data_o`   |   output    | BLOCK_AMOUNT*(BLOCK_AMOUNT-1)/2 | выходные данные            |

*Таблица 4: Общие входные порты AXI4-lite интерфейса*
| Название порта | Направление | Ширина | Описание порта      |
| -------------- | :---------: | :----: | ------------------- |
| `aclk_i`       |    input    |   1    | сигнал тактирования |
| `arstn_i`      |    input    |   1    | сигнал сброса       |

*Таблица 5: входные выходные порты AXI4-lite slave*
| Название порта | Направление |   Ширина   | Описание порта                                       |
| -------------- | :---------: | :--------: | ---------------------------------------------------- |
| `awvalid_i`    |    input    |     1      | Сигнал действительности адреса — мастер подаёт адрес |
| `awready_o`    |   output    |     1      | Подтверждение готовности slave принять адрес         |
| `awaddr_i`     |    input    | ADDR_WIDTH | Адрес для записи (байтовый адрес)                    |
| `awprot_i`     |    input    |     3      | Атрибут защиты                                       |
| `wvalid_i`     |    input    |     1      | Сигнал подтверждения данных                          |
| `wready_o`     |   output    |     1      | slave готов принять данные                           |
| `wdata_i`      |    input    | DATA_WIDTH | Передаваемые данные для записи                       |
| `wstrb_i`      |    input    |     4      | Маска байтов                                         |
| `bvalid_o`     |   output    |     1      | Ответ действителен                                   |
| `bready_i`     |    input    |     1      | Мастер готов принять ответ                           |
| `bresp_o`      |   output    |     2      | Код ответа на запись                                 |
| `arvalid_i`    |    input    |     1      | Сигнал действительности адреса чтения                |
| `arready_o`    |   output    |     1      | Готовность slave принять адрес                       |
| `araddr_i`     |    input    | ADDR_WIDTH | Адрес чтения                                         |
| `arprot_i`     |    input    |     3      | Атрибут защиты                                       |
| `rvalid_o`     |   output    |     1      | Сигнал действительности данных                       |
| `rready_i`     |    input    |     1      | Мастер готов принять данные                          |
| `rdata_o`      |   output    | DATA_WIDTH | Прочитанные данные                                   |
| `rresp_o`      |   output    |     2      | Код ответа                                           |

*Таблица 6: входные выходные порты AXI4-lite master*
| Название порта | Направление |   Ширина   | Описание порта                                       |
| -------------- | :---------: | :--------: | ---------------------------------------------------- |
| `awvalid_o`    |   output    |     1      | Сигнал действительности адреса — мастер подаёт адрес |
| `awready_i`    |    input    |     1      | Подтверждение готовности slave принять адрес         |
| `awaddr_o`     |   output    | ADDR_WIDTH | Адрес для записи (байтовый адрес)                    |
| `awprot_o`     |   output    |     3      | Атрибут защиты                                       |
| `wvalid_o`     |   output    |     1      | Сигнал подтверждения данных                          |
| `wready_i`     |    input    |     1      | slave готов принять данные                           |
| `wdata_o`      |   output    | DATA_WIDTH | Передаваемые данные для записи                       |
| `wstrb_o`      |   output    |     4      | Маска байтов                                         |
| `bvalid_i`     |    input    |     1      | Ответ действителен                                   |
| `bready_o`     |   output    |     1      | Мастер готов принять ответ                           |
| `bresp_i`      |    input    |     2      | Код ответа на запись                                 |
| `arvalid_o`    |   output    |     1      | Сигнал действительности адреса чтения                |
| `arready_i`    |    input    |     1      | Готовность slave принять адрес                       |
| `araddr_o`     |   output    | ADDR_WIDTH | Адрес чтения                                         |
| `arprot_o`     |   output    |     3      | Атрибут защиты                                       |
| `rvalid_i`     |    input    |     1      | Сигнал действительности данных                       |
| `rready_o`     |   output    |     1      | Мастер готов принять данные                          |
| `rdata_i`      |    input    | DATA_WIDTH | Прочитанные данные                                   |
| `rresp_i`      |    input    |     2      | Код ответа                                           |

# Описание внутренних модулей

## Описание работы интерфейса

### Хранение запросов к кэш

Для реализации хранения запросов в кэш используется FIFO хранящий в себе признак принадлежности транзакции к записи или чтению, адрес и данные. В случае одновременного запроса на запись и чтение, запись будет более приоритетной.

### Запись в кэш

Так как протоколом AXI-Lite не запрещены ситуации при которых данные с aw канала приходят раньше или позже чам данные с w канала, было решено использовать 2 буфера для каждого из каналов. Таким образом если сначала пришёл адрес записи, и только через пару тактов придут сами данные, начало транзакции будет смотреться по моменту прихода адреса. В это время транзакции чтения обрабатываться не будут. После того как по обоим каналам пришли валидные данные, транзакция записи считается обработанной. В случае занятости кэша, данная транзакция отправится в буфер.

### Сигнал `wstrb_i`

Данный сигнал учитывается при записи данных в память кэша.

### Сигналы  `rresp_o`, `rresp_i`, `bresp_i` и `bresp_o`

Входные сигналы будут игнорироваться, а выходные всегда выставлены в OKAY.

### Сигналы `arprot_i` и `awprot_i`

Данные сигналы буду игнорироваться, а на выходы `awprot_o` и `arprot_o` будет выставлена константа `010`

## Структурная схема Кэша

![*Рисунок 1: Структура блока кэш*](img/cache.svg)

*Рисунок 2: Структура cache*

### Внутренняя работа Кэша

Вся память в Кэше разделена на $2^{SET\_BITS}$ наборов, которые в свою очередь разделены на $2^{BLOCK\_BITS}$ блоков. Каждый блок хранит в себе флаг валидности данных (valid), флаг перезаписанных данных (dirty), уникальный адрес по которому его можно идентифицировать (tag) и сами данные (data).

Таким образом при получении запроса на чтение со стороны CPU входящий адрес разбивается на 2 составляющие:

- `tag` - `ADDR_WIDTH - byte offset - SET_BITS` старших битов адреса, где `byte offset` = log2(DATA_WIDTH/8)
- `set` - находится между `tag` и `byte_offset`, а именно, в интервале `[byte_offset + SET_BITS-1 : byte_offset]`

После разбиения адреса на составляющие происходит выбор набора и блока в котором лежат данные. Для записи существует 2 ситуации:

- Данные перезаписываются по уже существующему в кэше адресу
- Данные перезаписываются по новому адресу

Рассмотрим каждую ситуацию поподробнее.

В первом случае значение поля tag адреса и значение поля tag в одном из блоков набора совпали. Данные выставленные на входе блока cache перезаписывают данные выбранного блока. После этой операции у перезаписанного блока поднимается бит dirty. Он необходим для синхронизации данных кэша с основной памятью после выталкивания грязных данных из модуля.

Во втором случае значение поля tag адреса и значение поля tag ни в одном из блоков набора не совпали. Если в указанном наборе есть свободный блок, данные с tag записываются в него после чего поднимается бит dirty. Но может произойти так, что в указанном наборе не будет свободного блока. В таком случае какой то из блоков придётся "вытолкнуть". Выбор того, какие именно данные будут вытолкнуты будет происходить с использованием метода LRU, принцип которого описан ниже.

 В свою очередь для чтения так же существует 2 ситуации:

- Данные нашлись в Кэше (попадание)
- Данные не были найдены в Кэше (промах)
  - В наборе всё ещё есть свободные блоки
  - Все блоки в наборе заняты
    - Блок содержит в себе изменённые данные
    - Блок не был изменён

Рассмотрим каждую ситуацию поподробнее.

В первом случае значение поля tag адреса и значение поля tag в одном из блоков набора совпали. Этот случай называется *попадание*. На следующем такте данные выставляются на выход cache и CPU может их прочитать.

Во втором случае значение поля tag адреса и значение поля tag ни в одном из блоков набора не совпали. Этот случай называется *промах*. Происходит запрос на чтение из основной памяти по адресу выставленному CPU. Это занимает большое количество тактов, что затормаживает работу CPU. При получении кэшем данных из основной памяти он записывает их в себя, в случае если в указанном наборе есть свободный блок, данные с tag записываются в него после чего, на следующем такте попадают на CPU. Но может произойти так, что в указанном наборе не будет свободного блока. В таком случае какой то из блоков придётся "вытолкнуть". Выбор того, какие именно данные будут вытолкнуты будет происходить с использованием метода LRU, принцип которого описан ниже.

Может произойти так, что в процессе работы CPU изменит какие-то данные после чего отправит их обратно в кеш (данный блок будет считаться грязным и будет отмечен dirty битом). Если при промахе будет вытолкнут именно этот блок, то его данные вместе с адресом будут записаны в write-back буфер, из которого они попадут в основную память не тормозя работу CPU. При попытке вытолкнуть грязные данные в заполненный буфер чтение будет приостановлено до момента освобождения места в буфере. В случае замещения "чистых" данных, они не будут никуда записаны и просто пропадут.

# Описание write-back buffer

Write-back buffer используется для того что бы хранить в себе, измененные в процессе работы CPU данные с их адресами и последующей их отправки в основную память.

## Структурная схема write-back buffer

![text](img/wb_buffer.svg)

*Рисунок 3: Структура write-back буфера*

### Внутренняя работа write-back buffer

Та часть write-back буфера которая отсылает данные в основную память работает по аналогии с FIFO. Но помимо работы с основной памятью данный буфер позволяет считывать из него ещё не отправленные данные напрямую CPU. Из-за этого сторона работающая с CPU практически идентична работе кэша. Но есть одно отличие, адрес в write-back буфере не обрезается до размеров tag, а хранится целиком.

При записи в буфер данные помечаются битом валидности, обозначающим, что данные ещё не были отправлены в основную память, а указатель на запись передвигается на следующую ячейку

В случае промаха в кэше при запросе на чтение с CPU будет проверятся наличие искомых данных в write-back буфере. При их успешном нахождении данные отправятся как на CPU, так и в кэш по указанному адресу. При отсутствии данных как в кэше так и в write-back буфере, на следующий такт к основной памяти выставляется запрос на чтение по указанному адресу. В случае выталкивания "грязных" данных из кэша

Отправка данных из буфера в основную память происходит при "handshake", при этом бит валидности обнуляется и указатель на чтение перемещается на 1 ячейку вперед.

# Описание представления наборов и блоков в внешнем блоке памяти

Во внешнюю память будут записываться только данные. Такие поля как valid, dirty и tag будут реализованы на регистрах и будут располагаться внутри модуля cache.

![alt text](img/TECH_MEM.svg)

Соответственно адрес будет формироваться по принципу addr = [SET_BITS + BLOCK_BITS - 1: BLOCK_BITS] - отвечает за выбор сета [BLOCK_BITS-1: 0] - отвечает за выбор блока

Формирование сигналов `we_i` и `en_i` происходит внутри кэша.

# Описание LRU подхода

Суть используемого метода:

В выбранном set выталкивается блок к которому не обращались дольше всего.

Описание реализации:

Составляется матрица NxN, где N - количество блоков в наборе. На главной диагонали данной матрицы всегда 0. Когда идёт обращение к i-тому блоку, в i-той строке матрицы выставляются единицы, после чего в i-том столбце матрицы выставляются нули.

***Начальное состояние:***

*Таблица 7: начальное состояние матрицы в методе LRU*
|       | **0** | **1** | **2** | **3** |
| :---: | :---: | :---: | :---: | :---: |
| **0** |   0   |   1   |   1   |   1   |
| **1** |   0   |   0   |   1   |   1   |
| **2** |   0   |   0   |   0   |   1   |
| **3** |   0   |   0   |   0   |   0   |

*Таблица 8: состояние матрицы после последовательности обращения к следующим блокам (3,1,0,2,0,3,2)*
|       | **0** | **1** | **2** | **3** |
| :---: | :---: | :---: | :---: | :---: |
| **0** |   0   |   1   |   0   |   0   |
| **1** |   0   |   0   |   0   |   0   |
| **2** |   1   |   1   |   0   |   1   |
| **3** |   1   |   1   |   0   |   0   |

Номер строки в которой нет единичных битов и есть номер дольше всего не использовавшегося блока.

Представим это в таком виде:

Если обозначить матрицу буквой М, то M<sub>ij</sub> указывает был ли блок i использован после блока j. Если M<sub>ij</sub> = 1, то блок i использовался после блока j, а если M<sub>ij</sub> = 0, то блок i использовался не позже блока j.

Для того что бы понять является ли j блок кандидатом на выталкивание достаточно выполнение условия логическое и между всеми M<sub>ij</sub> при фиксированном j (кроме i == j) должен быть 1.

Из этого можно сделать вывод что нам достаточно иметь верхнюю или нижнюю часть относительно главной диагонали матрицы. Следовательно для каждого set достаточно n*(n-1)/2 битов. Данные "ужатые" представления матриц будут храниться в Tech.MEM для каждого набора по отдельному адресу.

Номер блока который надо вытолкнуть будет определяться как Push &= M<sub>ij</sub> , где j равна номеру блока, а i меняется от 0 до N за исключением самого j. Так как мы используем только нижнюю половину матрицы. Все M<sub>ij</sub> в которых j > i должны будут считаться как ~M<sub>ji</sub>.

## Сигналы синхронизации и сброса

Сигналом синхронизации является `aclk_i`. Данный сигнал должен быть синхронен с системной шиной. Весь блок работает в одном тактовом домене.

Сигналом сброс является `arstn_i`. Он сбрасывает всю логику блока, его активным уровнем является 0. Данный сигнал должен быть синхронен с системной шиной.

Из-за особенности реализации LRU после сброса основная логика кэша будет заблокирована в течении $2^{BLOCK\_BITS}$ в это время будет происходить инициализация память матриц для LRU. При этом обработка транзакций чтения и записи будет работать в штатном режиме (до полного заполнения буфера).

## Сценарии применения блока

- применяется между CPU и памятью

## Программная модель

Отсутствует

## Питание

Вся логика находится в одном домене питания. Специальных требований не предъявляется.
